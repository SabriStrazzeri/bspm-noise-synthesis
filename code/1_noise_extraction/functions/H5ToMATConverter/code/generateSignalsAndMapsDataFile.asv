function episode = generateSignalsAndMapsDataFile(path, session_name, ID_map)
% Last edited: 14/11/2024 (Marta Martínez) - correct field name
% segment.bspm.irregularRhythmAnalysis, mapID in globalVariables, added new
% field H5ToMATConverter in metadata
%
% Last edited: 12/02/2025 (Marta Martínez) - add analysis data if map data
% does not exist

% MAP: Convert .h5/.hd5 map file to .mat 
try
    try % file from acorys converter
        try
            map_filename = [session_name, '_get_map_model_', num2str(ID_map), '.h5'];
            path_map = [path,'\', map_filename];
            map = h5loadmod(path_map);
        catch
            map_filename = [session_name, '_get_map_model_', num2str(ID_map), '.hd5'];
            path_map = [path,'\', map_filename];
            map = h5loadmod(path_map);
        end
    catch % file from HORTA
        map_filename = [session_name, '_MAP_', num2str(ID_map), '.h5'];
        path_map = [path,'\', map_filename];
        map = h5loadmod(path_map);
    end

    disp(['Map name: ', map.bbdindex.Name])

    fileMap = 1; 
catch
    fileMap = 0; 
end 

% EVENT: Convert .h5/.hd5 map file to .mat 
try
    try % file from acorys converter
        try
            event_filename = [session_name, '_get_analysis_from_analysis_id_', num2str(ID_map), '.h5'];
            path_event = [path,'\', event_filename];
            event = h5loadmod(path_event);
        catch
            event_filename = [session_name, '_get_analysis_from_analysis_id_', num2str(ID_map), '.hd5'];
            path_event = [path,'\', event_filename];
            event = h5loadmod(path_event);
        end
    catch % file from HORTA

    end

    disp(['Map name: ', event.Item1.Name])

    fileEvent = 1; 
catch
    fileEvent = 0; 
end 

% SIGNALS: Convert .h5/.hd5 signals file to .mat 
try
    try % file from acorys converter
        try
            signals_filename = [session_name, '_get_signals_from_mapID_', num2str(ID_map), '.h5']; 
            path_signals = [path, '\',signals_filename];
            signals = h5loadmod(path_signals);
        catch
            signals_filename = [session_name, '_get_signals_from_mapID_', num2str(ID_map), '.hd5']; 
            path_signals = [path, '\',signals_filename];
            signals = h5loadmod(path_signals);
        end
    catch % file from HORTA
        signals_filename = [session_name, '_SIGNALS_MAP_', num2str(ID_map), '.h5'];
        path_signals = [path, '\',signals_filename];
        signals = h5loadmod(path_signals);
    end

    fileSignals = 1; 
catch
    fileSignals = 0; 
end 


%% Global variables 
%----------------------------------------------------------------------
episode.globalVariables.fs = 1000; 

if fileMap == 1
    episode.globalVariables.leadStatus = double(map.mapmodel.Map1.LeadSelection)'; 
elseif fileEvent == 1
    episode.globalVariables.leadStatus = event.Item2.LeadStatus; 
elseif fileSignals == 1
    episode.globalVariables.leadStatus = signals.leadStatus; 
else
    episode.globalVariables.leadStatus = []; 
end 

if fileSignals == 1
    episode.globalVariables.WCT3 = signals.ctws;
    episode.globalVariables.WCTall = find(episode.globalVariables.leadStatus == 1);
else 
    episode.globalVariables.WCT3 = []; 
    episode.globalVariables.WCTall = []; 
end 

if fileMap == 1
    episode.globalVariables.mapName = map.bbdindex.Name;
    episode.globalVariables.mapID = map.mapmodel.Id;
elseif fileEvent == 1
    episode.globalVariables.mapName = event.Item1.Name;
    episode.globalVariables.mapID = [];
else
    episode.globalVariables.mapName = [];
    episode.globalVariables.mapID = [];
end

%% Metadata
%----------------------------------------------------------------------

if contains(session_name, 'ACAMP')

    session_name_split = strsplit(session_name, '_');
    ACAMPversion = session_name_split{1};

else

    ACAMPversion = [];

end

% Versions
episode.metadata.versions.ACSOFversion = 'ACSOF 1.2';              % (no lo devuelve ACORYS)
episode.metadata.versions.ACSENversion = [];               % (no lo devuelve ACORYS)
episode.metadata.versions.ACSCANversion = [];             % (no lo devuelve ACORYS)
episode.metadata.versions.ACAMPversion = ACAMPversion;               
episode.metadata.versions.FIRMWAREversion = [];         % (no lo devuelve ACORYS)
episode.metadata.versions.SHAPEMODELversion = [];    % (no lo devuelve ACORYS)
episode.metadata.versions.ChannelMapping = [];                      % Esto diría que es un vector (no lo devuelve ACORYS)
episode.metadata.versions.ITACArelease = [];                % (no lo devuelve ACORYS)
episode.matadata.versions.H5ToMATConverter = 'H5ToMATConverter12_20250212'; 

% Date 
if fileMap == 1
    episode.metadata.date.registerDate = [];  % (no lo devuelve ACORYS)
    episode.metadata.date.analysisDate = map.mapmodel.date; 
elseif fileEvent == 1
    episode.metadata.date.registerDate = [];  % (no lo devuelve ACORYS)
    episode.metadata.date.analysisDate = event.Item1.AnalysisTime; 
else 
    episode.metadata.date.registerDate = [];  
    episode.metadata.date.analysisDate = []; 
end 

% Patient data
episode.metadata.patientData.age = [];              % (no lo devuelve ACORYS)
episode.metadata.patientData.sex = [];             % (no lo devuelve ACORYS)
episode.metadata.patientData.clinicalData = [];      % (no lo devuelve ACORYS)
episode.metadata.patientData.patientID = session_name;   


%% BSPM segment
%----------------------------------------------------------------------

if fileMap == 1

    analysisType = map.mapmodel.Map1.mapType; 
    
    if ~isstruct(map.mapmodel.Map1)
        mapAtria = 0; 
    else
        mapAtria = 1; 
    end 
    
    if ~isstruct(map.mapmodel.Map2)
        mapVentricles = 0; 
    else
        mapVentricles = 1; 
    end 


    switch(analysisType)
        case 'MapSingleBeat'
            % BSPM Single beat 
            if mapAtria == 1
                episode.segment.bspm.singleBeatAnalysis.voltage = map.mapmodel.Map1.ECGData(1:128,:);                    % segmento de ECG filtrado de la señal de 1 min
                episode.segment.bspm.singleBeatAnalysis.idxVoltage = [typecast(single(map.mapmodel.Map1.ECGData(129,1)), 'uint32'), typecast(single(map.mapmodel.Map1.ECGData(129,end)), 'uint32')]+1;          
                episode.segment.bspm.singleBeatAnalysis.idxPwave = [map.mapmodel.Map1.QRSon, map.mapmodel.Map1.QRSoff];
            else
                episode.segment.bspm.singleBeatAnalysis.voltage = []; 
                episode.segment.bspm.singleBeatAnalysis.idxVoltage = [];   
                episode.segment.bspm.singleBeatAnalysis.idxPwave = [];
            end 
    
            if mapVentricles == 1
                 episode.segment.bspm.singleBeatAnalysis.voltage = map.mapmodel.Map2.ECGData(1:128,:);                    % segmento de ECG filtrado de la señal de 1 min
                 episode.segment.bspm.singleBeatAnalysis.idxVoltage = [typecast(single(map.mapmodel.Map2.ECGData(129,1)), 'uint32'), typecast(single(map.mapmodel.Map2.ECGData(129,end)), 'uint32')]+1; 
                 episode.segment.bspm.singleBeatAnalysis.idxQRScomplex = [map.mapmodel.Map2.QRSon, map.mapmodel.Map2.QRSoff]; 
                 episode.segment.bspm.singleBeatAnalysis.idxTwave = [];  % no lo exporta ACORYS
            else 
                episode.segment.bspm.singleBeatAnalysis.idxQRScomplex = [];   
                episode.segment.bspm.singleBeatAnalysis.idxTwave = [];
            end 
    
            episode.segment.bspm.singleBeatAnalysis.idxEvent = map.mapmodel.BeatEventID; 
    
            episode.segment.bspm.averageBeatAnalysis = []; 
            episode.segment.bspm.irregularRhythmAnalysis = []; 
    
    
        case 'MapAveraged'
            % BSPM Average beat
            if mapAtria == 1
                episode.segment.bspm.averageBeatAnalysis.voltage = [];                                              % segmento de ECG filtrado de la señal de 1 min (no lo devuelve ACORYS)
                episode.segment.bspm.averageBeatAnalysis.idxVoltage = [];                                           % idx del segmento respecto de la señal raw (no lo devuelve ACORYS)          
                episode.segment.bspm.averageBeatAnalysis.voltageAverage = map.mapmodel.Map1.ECGData(1:128,:);            % ECG promediado (no tengo un ejemplo, pero recorto un latido a modo de promedio)
                episode.segment.bspm.averageBeatAnalysis.idxAverage = [1, length(map.mapmodel.Map1.ECGData(1:128,:))];   % idx del tramo del segmento de ECG para calcular el promedio  
                episode.segment.bspm.averageBeatAnalysis.idxPwave = [map.mapmodel.Map1.QRSon, map.mapmodel.Map1.QRSoff];
            else
                episode.segment.bspm.averageBeatAnalysis.voltage = []; 
                episode.segment.bspm.averageBeatAnalysis.idxVoltage = [];   
                episode.segment.bspm.averageBeatAnalysis.idxPwave = [];
            end 
    
            if mapVentricles == 1
                episode.segment.bspm.averageBeatAnalysis.voltage = [];                                              % segmento de ECG filtrado de la señal de 1 min (no lo devuelve ACORYS)
                episode.segment.bspm.averageBeatAnalysis.idxVoltage = [];                                           % idx del segmento respecto de la señal raw (no lo devuelve ACORYS)          
                episode.segment.bspm.averageBeatAnalysis.voltageAverage = map.mapmodel.Map2.ECGData(1:128,:);            % ECG promediado (no tengo un ejemplo, pero recorto un latido a modo de promedio)
                episode.segment.bspm.averageBeatAnalysis.idxAverage = [];                                           % idx del tramo del segmento de ECG para calcular el promedio  
                episode.segment.bspm.averageBeatAnalysis.idxQRScomplex = [map.mapmodel.Map2.QRSon, map.mapmodel.Map2.QRSoff]; 
                episode.segment.bspm.averageBeatAnalysis.idxTwave = [];                                             % no lo devuelve ACORYS
            else
                episode.segment.bspm.averageBeatAnalysis.idxQRScomplex = []; 
                episode.segment.bspm.averageBeatAnalysis.idxTwave = [];
            end 
    
            episode.segment.bspm.averageBeatAnalysis.idxEvent = map.mapmodel.BeatEventID; 
    
            episode.segment.bspm.singleBeatAnalysis = []; 
            episode.segment.bspm.irregularRhythmAnalysis = []; 
    
        case 'MapIrregularAdvanced'
            % BSPM Irregular rhythm

            episode.segment.bspm.irregularRhythmAnalysis.voltage = []; % no lo devuelve como tal el exporter, lo mas cercano es signals.DataFiltered que es un tramo que contiene la ventana de ECGi, pero no tienen porque coincidir con ECGData
            episode.segment.bspm.irregularRhythmAnalysis.idxVoltage = [typecast(single(map.mapmodel.Map1.ECGData(129,1)), 'uint32'), typecast(single(map.mapmodel.Map1.ECGData(129,end)), 'uint32')]+1; 
            episode.segment.bspm.irregularRhythmAnalysis.voltageAtrialActivity = map.mapmodel.Map1.ECGData(1:128,:);    
            episode.segment.bspm.irregularRhythmAnalysis.idxAtrialActivity = [map.mapmodel.Map1.QRSon, map.mapmodel.Map1.QRSoff];
            episode.segment.bspm.irregularRhythmAnalysis.idxEvent = map.mapmodel.BeatEventID; 
    
            episode.segment.bspm.singleBeatAnalysis = []; 
            episode.segment.bspm.averageBeatAnalysis = []; 
    
    end 


elseif fileEvent == 1

    eventType = event.Item1.EventType; 
   
    switch(eventType)
        case 'SingleBeat'

            % BSPM Single beat 
            episode.segment.bspm.singleBeatAnalysis.voltage = event.Item2.Data;                    % segmento de ECG filtrado de la señal de 1 min
            episode.segment.bspm.singleBeatAnalysis.idxVoltage = [];  %[event.Item2.CounterSessionStart, event.Item2.CounterSessionEnd];         
            episode.segment.bspm.singleBeatAnalysis.idxPwave = [event.Item2.PwaveOn, event.Item2.PwaveOff];
            episode.segment.bspm.singleBeatAnalysis.idxQRScomplex = [event.Item2.QRSOn, event.Item2.QRSOff]; 
            episode.segment.bspm.singleBeatAnalysis.idxTwave = [event.Item2.TwaveOn, event.Item2.TwaveOff];  
            episode.segment.bspm.singleBeatAnalysis.idxEvent = event.Item2.Id; 
    
            episode.segment.bspm.averageBeatAnalysis = []; 
            episode.segment.bspm.irregularRhythmAnalysis = []; 
    
    
        case 'AveragedBeat' 

            % BSPM Average beat
            episode.segment.bspm.averageBeatAnalysis.voltage = [];                                              % segmento de ECG filtrado de la señal de 1 min (no lo devuelve ACORYS)
            episode.segment.bspm.averageBeatAnalysis.idxVoltage = [];                                           % idx del segmento respecto de la señal raw (no lo devuelve ACORYS)          
            episode.segment.bspm.averageBeatAnalysis.voltageAverage = [event.Item2.Data];             % ECG promediado (no tengo un ejemplo, pero recorto un latido a modo de promedio)
            episode.segment.bspm.averageBeatAnalysis.idxAverage = [];    % idx del tramo del segmento de ECG para calcular el promedio  
            episode.segment.bspm.averageBeatAnalysis.idxPwave = [event.Item2.PwaveOn, event.Item2.PwaveOff]; 
            episode.segment.bspm.averageBeatAnalysis.idxQRScomplex = [event.Item2.QRSOn, event.Item2.QRSOff]; 
            episode.segment.bspm.averageBeatAnalysis.idxTwave = [event.Item2.TwaveOn, event.Item2.TwaveOff];
            episode.segment.bspm.averageBeatAnalysis.idxEvent = event.Item2.Id;  
    
            episode.segment.bspm.singleBeatAnalysis = []; 
            episode.segment.bspm.irregularRhythmAnalysis = []; 
    
        case 'Irregular'

            % BSPM Irregular rhythm
            episode.segment.bspm.irregularRhythmAnalysis.voltage = []; % no lo devuelve como tal el exporter, lo mas cercano es signals.DataFiltered que es un tramo que contiene la ventana de ECGi, pero no tienen porque coincidir con ECGData
            episode.segment.bspm.irregularRhythmAnalysis.idxVoltage = [];  %[event.Item2.CounterSessionStart, event.Item2.CounterSessionEnd];
            episode.segment.bspm.irregularRhythmAnalysis.voltageAtrialActivity = event.Item2.Data;   
            episode.segment.bspm.irregularRhythmAnalysis.idxAtrialActivity = [event.Item2.AtrialActivityIni  , event.Item2.AtrialActivityEnd];
            episode.segment.bspm.irregularRhythmAnalysis.idxEvent = event.Item2.Id;
    
            episode.segment.bspm.singleBeatAnalysis = []; 
            episode.segment.bspm.averageBeatAnalysis = []; 
    
    end 

else
    episode.segment.bspm = []; 
end 


%% ECGi segment
%----------------------------------------------------------------------
if fileMap == 1

    switch(analysisType)
        case 'MapSingleBeat'
            % ECGi single beat analysis
            if mapAtria == 1
                episode.segment.ecgi.singleBeatAnalysis.atria.voltage = map.mapmodel.Map1.ECGI; 
                episode.segment.ecgi.singleBeatAnalysis.atria.activationTimes.values = map.mapmodel.Map1.ActivationTimes.Values; 
                episode.segment.ecgi.singleBeatAnalysis.atria.activationTimes.maxLAT = max(episode.segment.ecgi.singleBeatAnalysis.atria.activationTimes.values); 
                if iscell(map.mapmodel.Map1.ConductionVelocity.Values)
                    episode.segment.ecgi.singleBeatAnalysis.atria.conductionVelocity.values = str2double(map.mapmodel.Map1.ConductionVelocity.Values);          % No sé si es la variable values o originalValues
                else
                    episode.segment.ecgi.singleBeatAnalysis.atria.conductionVelocity.values = map.mapmodel.Map1.ConductionVelocity.Values;
                end 
                episode.segment.ecgi.singleBeatAnalysis.atria.conductionVelocity.meanCV = mean(episode.segment.ecgi.singleBeatAnalysis.atria.conductionVelocity.values); 
                episode.segment.ecgi.singleBeatAnalysis.atria.ectopicMap = [];              % no lo devuelve ACORYS, pero serán = size(LATS)
            else
                episode.segment.ecgi.singleBeatAnalysis.atria.voltage = []; 
                episode.segment.ecgi.singleBeatAnalysis.atria.activationTimes.values = []; 
                episode.segment.ecgi.singleBeatAnalysis.atria.activationTimes.maxLAT = []; 
                episode.segment.ecgi.singleBeatAnalysis.atria.conductionVelocity.values = []; 
                episode.segment.ecgi.singleBeatAnalysis.atria.conductionVelocity.meanCV = []; 
                episode.segment.ecgi.singleBeatAnalysis.atria.ectopicMap = []; 
            end 
    
            if mapVentricles == 1
                episode.segment.ecgi.singleBeatAnalysis.ventricles.voltage = map.mapmodel.Map2.ECGI; 
                episode.segment.ecgi.singleBeatAnalysis.ventricles.activationTimes.values = map.mapmodel.Map2.ActivationTimes.Values; 
                episode.segment.ecgi.singleBeatAnalysis.ventricles.activationTimes.maxLAT = max(episode.segment.ecgi.singleBeatAnalysis.ventricles.activationTimes.values);  
                if iscell(map.mapmodel.Map2.ConductionVelocity.Values)
                    episode.segment.ecgi.singleBeatAnalysis.ventricles.conductionVelocity.values = str2double(map.mapmodel.Map2.ConductionVelocity.Values);          % No sé si es la variable values o originalValues
                else
                    episode.segment.ecgi.singleBeatAnalysis.ventricles.conductionVelocity.values = (map.mapmodel.Map2.ConductionVelocity.Values);
                end 
                episode.segment.ecgi.singleBeatAnalysis.ventricles.conductionVelocity.meanCV = mean(episode.segment.ecgi.singleBeatAnalysis.ventricles.conductionVelocity.values); 
                episode.segment.ecgi.singleBeatAnalysis.ventricles.ectopicMap = [];              % no lo devuelve ACORYS, pero serán = size(LATS)
            else
                episode.segment.ecgi.singleBeatAnalysis.ventricles.voltage = []; 
                episode.segment.ecgi.singleBeatAnalysis.ventricles.activationTimes.values = []; 
                episode.segment.ecgi.singleBeatAnalysis.ventricles.activationTimes.maxLAT = []; 
                episode.segment.ecgi.singleBeatAnalysis.ventricles.conductionVelocity.values = []; 
                episode.segment.ecgi.singleBeatAnalysis.ventricles.conductionVelocity.meanCV = []; 
                episode.segment.ecgi.singleBeatAnalysis.ventricles.ectopicMap = []; 
            end 
    
            episode.segment.ecgi.averageBeatAnalysis = []; 
            episode.segment.ecgi.irregularRhythmAnalysis = []; 
    
        
        case 'MapAveraged'
            % ECGi average beat analysis
            if mapAtria == 1
                episode.segment.ecgi.averageBeatAnalysis.atria.voltage = map.mapmodel.Map1.ECGI; 
                episode.segment.ecgi.averageBeatAnalysis.atria.activationTimes.values = map.mapmodel.Map1.ActivationTimes.Values; 
                episode.segment.ecgi.averageBeatAnalysis.atria.activationTimes.maxLAT = max(episode.segment.ecgi.averageBeatAnalysis.atria.activationTimes.values);    
                if iscell(map.mapmodel.Map1.ConductionVelocity.Values)
                    episode.segment.ecgi.averageBeatAnalysis.atria.conductionVelocity.values = str2double(map.mapmodel.Map1.ConductionVelocity.Values);          % No sé si es la variable values o originalValues
                else
                    episode.segment.ecgi.averageBeatAnalysis.atria.conductionVelocity.values = (map.mapmodel.Map1.ConductionVelocity.Values);
                end 
                episode.segment.ecgi.averageBeatAnalysis.atria.conductionVelocity.meanCV = mean(episode.segment.ecgi.averageBeatAnalysis.atria.conductionVelocity.values); 
                episode.segment.ecgi.averageBeatAnalysis.atria.ectopicMap = [];              % no lo devuelve ACORYS, pero serán = size(LATS)
            else
                episode.segment.ecgi.averageBeatAnalysis.atria.voltage = []; 
                episode.segment.ecgi.averageBeatAnalysis.atria.activationTimes.values = [];
                episode.segment.ecgi.averageBeatAnalysis.atria.activationTimes.maxLAT = []; 
                episode.segment.ecgi.averageBeatAnalysis.atria.conductionVelocity.values = []; 
                episode.segment.ecgi.averageBeatAnalysis.atria.conductionVelocity.meanCV = []; 
                episode.segment.ecgi.averageBeatAnalysis.atria.ectopicMap = []; 
            end 
            
            if mapVentricles == 1
                episode.segment.ecgi.averageBeatAnalysis.ventricles.voltage = map.mapmodel.Map2.ECGI; 
                episode.segment.ecgi.averageBeatAnalysis.ventricles.activationTimes.values = map.mapmodel.Map2.ActivationTimes.Values; 
                episode.segment.ecgi.averageBeatAnalysis.ventricles.activationTimes.maxLAT = max(episode.segment.ecgi.averageBeatAnalysis.ventricles.activationTimes.values); 
                if iscell(map.mapmodel.Map2.ConductionVelocity.Values)
                    episode.segment.ecgi.averageBeatAnalysis.ventricles.conductionVelocity.values = str2double(dataMap.Map2.ConductionVelocity.Values);          % No sé si es la variable values o originalValues
                else
                    episode.segment.ecgi.averageBeatAnalysis.ventricles.conductionVelocity.values = (map.mapmodel.Map2.ConductionVelocity.Values);
                end 
                episode.segment.ecgi.averageBeatAnalysis.ventricles.conductionVelocity.meanCV = mean(episode.segment.ecgi.averageBeatAnalysis.ventricles.conductionVelocity.values);                         
                episode.segment.ecgi.averageBeatAnalysis.ventricles.ectopicMap = [];              % no lo devuelve ACORYS, pero serán = size(LATS)
            else 
                episode.segment.ecgi.averageBeatAnalysis.ventricles.voltage = []; 
                episode.segment.ecgi.averageBeatAnalysis.ventricles.activationTimes.values = []; 
                episode.segment.ecgi.averageBeatAnalysis.ventricles.activationTimes.maxLAT = []; 
                episode.segment.ecgi.averageBeatAnalysis.ventricles.conductionVelocity.values = []; 
                episode.segment.ecgi.averageBeatAnalysis.ventricles.conductionVelocity.meanCV = []; 
                episode.segment.ecgi.averageBeatAnalysis.ventricles.ectopicMap = []; 
            end 
    
            episode.segment.ecgi.singleBeatAnalysis = []; 
            episode.segment.ecgi.irregularRhythmAnalysis = []; 
    
        
        case 'MapIrregularAdvanced'
            % ECGi irregular rhythm analysis
            episode.segment.ecgi.irregularRhythmAnalysis.atria.voltage = map.mapmodel.Map1.ECGI;  

            episode.segment.ecgi.irregularRhythmAnalysis.atria.phase = map.mapmodel.Map1.PhaseMap.Values';                             
            episode.segment.ecgi.irregularRhythmAnalysis.atria.rotorHistogram.values = map.mapmodel.Map1.Rotorhistogram.Values;  
            episode.segment.ecgi.irregularRhythmAnalysis.atria.meanDF.values = map.mapmodel.Map1.MeanDF.Values;
            episode.segment.ecgi.irregularRhythmAnalysis.atria.stdDF.values = map.mapmodel.Map1.StdDF.Values;
            episode.segment.ecgi.irregularRhythmAnalysis.atria.histHDF.values = map.mapmodel.Map1.HistHDF.Values;
            
            % episode.segment.ecgi.irregularRhythmAnalysis.atria.curlHistogram = [];

            episode.segment.ecgi.singleBeatAnalysis = []; 
            episode.segment.ecgi.averageBeatAnalysis = []; 
    
    end 

else
    episode.segment.ecgi = []; 
end 

%% Signals
if fileSignals == 1

    %% BSPM segment
    %----------------------------------------------------------------------
    % Raw BSPM 
    episode.segment.bspm.rawVoltage.rawVoltage = signals.DataRaw(1:128,:); 
    episode.segment.bspm.rawVoltage.filteredVoltage = signals.DataFiltered(1:128,:); 
    episode.segment.bspm.rawVoltage.counter = double(signals.counter);                               

    try
        episode.segment.bspm.rawVoltage.lowerBound = signals.LowerBound;
        episode.segment.bspm.rawVoltage.upperBound = signals.UpperBound;
    catch
    end

end 

end 
